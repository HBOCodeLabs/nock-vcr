// Generated by CoffeeScript 1.4.0
(function() {
  var ALL, Cassette, NONE, ONCE, config, currentCassette, ejectCassette, ensureCassetteLibraryDirExists, exports, flushNockRecorder, fs, insertCassette, modes, nock, path, util, _currentCassette, _ref;

  nock = require('nock');

  fs = require('fs');

  util = require('util');

  path = require('path');

  ALL = 'ALL';

  ONCE = 'ONCE';

  NONE = 'NONE';

  modes = {
    ALL: ALL,
    ONCE: ONCE,
    NONE: NONE
  };

  config = {
    cassetteLibraryDir: 'test/cassettes',
    mode: (_ref = process.env.NOCK_VCR_MODE) != null ? _ref : ONCE,
    recordBodiesToFiles: false
  };

  _currentCassette = null;

  flushNockRecorder = function() {
    var call, calls, code, i, _i, _len;
    calls = nock.recorder.play();
    nock.recorder.clear();
    code = "module.exports = exports = function(nock) {";
    code += "\nvar refs = [];\n";
    for (i = _i = 0, _len = calls.length; _i < _len; i = ++_i) {
      call = calls[i];
      code += "\nrefs[" + i + "] = " + (call.substr(1));
    }
    code += "\n\nreturn refs;";
    code += "\n};";
    return code;
  };

  ensureDirExists = function(dirPath) {
    var currentDir, dir, _i, _len, _ref1, _results;
    currentDir = '.';
    _ref1 = dirPath.split(path.sep);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      dir = _ref1[_i];
      currentDir = path.resolve(currentDir, dir);
      if (!fs.existsSync(currentDir)) {
        _results.push(fs.mkdirSync(currentDir));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  }    

  Cassette = (function() {

    function Cassette(name, options, nockRecordOptions) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (name == null) {
        throw new Error("A name is needed for the cassette.");
      }
      Object.defineProperty(this, 'name', {
        value: name
      });
      Object.defineProperty(this, 'recordBodiesToFiles', {
	get: function() {
	  return options.recordBodiesToFiles == true;
	}
      });
      Object.defineProperty(this, 'cassetteDir', {
	get: function() {
	  if (this.recordBodiesToFiles) {
	    return path.join(config.cassetteLibraryDir, name);
	  } else {
	    return config.cassetteLibraryDir;
	  }
	}
      });
      Object.defineProperty(this, 'file', {
        get: function() {
          var fileName;
	  if (this.recordBodiesToFiles) {
	    fileName = "cassette.js";
	  } else {
            fileName = "" + (_this.name.split(/\W+/).join('-').toLowerCase()) + ".js";
	  }
          return path.join(this.cassetteDir, fileName);
        }
      });
      Object.defineProperty(this, 'exists', {
        get: function() {
          return fs.existsSync(_this.file);
        }
      });
      Object.defineProperty(this, 'recording', {
        get: function() {
          var recordMode, _ref1, _ref2;
          recordMode = (_ref1 = (_ref2 = options.record) != null ? _ref2 : config.mode) != null ? _ref1 : ONCE;
          switch (recordMode) {
            case ALL:
              return true;
            case NONE:
              return false;
            default:
              return !_this.exists;
          }
        }
      });
      Object.defineProperty(this, 'nockRecordOptions', {
	get: function() {
	  // Copy properties from user
	  recordOptions = { };
	  for (var optionKey in nockRecordOptions) {
	    recordOptions[optionKey] = nockRecordOptions[optionKey];
	  }
	  // Set options to record bodies to file
	  if (this.recordBodiesToFiles) {
	    recordOptions.recordBodiesToFiles = true;
	    recordOptions.bodyPath = this.cassetteDir;
	  }
	  return recordOptions;
	}
      });
    }

    Cassette.prototype.load = function() {
      ensureDirExists(this.cassetteDir);
      nock.cleanAll();
      nock.restore();
      if (this.recording) {
        return this.rec();
      } else {
        return this.play();
      }
    };

    Cassette.prototype.rec = function() {
      return nock.recorder.rec(true, this.nockRecordOptions);
    };

    Cassette.prototype.play = function() {
      var name;
      nock.activate();
      if (this.exists) {
        name = require.resolve(this.file);
        if (require.cache[name] != null) {
          delete require.cache[name];
        }
        return this.refs = (require(this.file))(nock);
      }
    };

    Cassette.prototype.eject = function() {
      var ref, _i, _len, _ref1, _results;
      if (this.recording) {
        return this.write();
      } else if (this.refs != null) {
        _ref1 = this.refs;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          ref = _ref1[_i];
          _results.push(ref.done());
        }
        return _results;
      }
    };

    Cassette.prototype.write = function() {
      var calls;
      calls = flushNockRecorder();
      return fs.writeFileSync(this.file, calls, 'utf8');
    };

    return Cassette;

  })();

  insertCassette = function(name, options, nockRecordOptions) {
    if (options == null) {
      options = {};
    }
    nock.cleanAll();
    if (_currentCassette != null) {
      throw new Error("Cassette '" + _currentCassette.name + "' already loaded!");
    }
    _currentCassette = new Cassette(name, options, nockRecordOptions);
    return _currentCassette.load();
  };

  ejectCassette = function() {
    try {
      return _currentCassette != null ? _currentCassette.eject() : void 0;
    } catch (error) {
      throw error;
    } finally {
      _currentCassette = null;
      nock.cleanAll();
    }
  };

  currentCassette = function() {
    return _currentCassette;
  };

  module.exports = exports = {
    insertCassette: insertCassette,
    ejectCassette: ejectCassette,
    currentCassette: currentCassette
  };

}).call(this);
